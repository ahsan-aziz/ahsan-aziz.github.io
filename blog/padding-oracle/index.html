<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Padding Oracle Attack | Ahsan's Blog</title><meta name=keywords content><meta name=description content="This post is an effort to explain the padding oracle attack for Cipher Block Chaining (CBC) mode of encryption. In a successful attack, an attacker can recover the plaintext without any knowledge of the key. If the application, which is handling the decryption, leaks information about the valid and invalid padding, an attacker can send specially crafted ciphertext blocks and recover the plaintext. Below are the detials of the attack."><meta name=author content><link rel=canonical href=https://ahsan-aziz.github.io/blog/padding-oracle/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ahsan-aziz.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ahsan-aziz.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ahsan-aziz.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ahsan-aziz.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ahsan-aziz.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Padding Oracle Attack"><meta property="og:description" content="This post is an effort to explain the padding oracle attack for Cipher Block Chaining (CBC) mode of encryption. In a successful attack, an attacker can recover the plaintext without any knowledge of the key. If the application, which is handling the decryption, leaks information about the valid and invalid padding, an attacker can send specially crafted ciphertext blocks and recover the plaintext. Below are the detials of the attack."><meta property="og:type" content="article"><meta property="og:url" content="https://ahsan-aziz.github.io/blog/padding-oracle/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-07-24T07:10:07-04:00"><meta property="article:modified_time" content="2023-07-24T07:10:07-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Padding Oracle Attack"><meta name=twitter:description content="This post is an effort to explain the padding oracle attack for Cipher Block Chaining (CBC) mode of encryption. In a successful attack, an attacker can recover the plaintext without any knowledge of the key. If the application, which is handling the decryption, leaks information about the valid and invalid padding, an attacker can send specially crafted ciphertext blocks and recover the plaintext. Below are the detials of the attack."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://ahsan-aziz.github.io/blog/"},{"@type":"ListItem","position":3,"name":"Padding Oracle Attack","item":"https://ahsan-aziz.github.io/blog/padding-oracle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Padding Oracle Attack","name":"Padding Oracle Attack","description":"This post is an effort to explain the padding oracle attack for Cipher Block Chaining (CBC) mode of encryption. In a successful attack, an attacker can recover the plaintext without any knowledge of the key. If the application, which is handling the decryption, leaks information about the valid and invalid padding, an attacker can send specially crafted ciphertext blocks and recover the plaintext. Below are the detials of the attack.","keywords":[],"articleBody":"This post is an effort to explain the padding oracle attack for Cipher Block Chaining (CBC) mode of encryption. In a successful attack, an attacker can recover the plaintext without any knowledge of the key. If the application, which is handling the decryption, leaks information about the valid and invalid padding, an attacker can send specially crafted ciphertext blocks and recover the plaintext. Below are the detials of the attack.\nPadding First, let’s discuss how padding works. As CBC is a block cipher, data is encrypted in blocks and all the blocks are of equal size. Before encryption, the plaintext is divided into blocks, and because the plaintext can be of arbitrary length, we need to add padding to match the block size. In PKCS#5, the final block of plaintext is padded with N bytes of value N. For example, for an 8 byte block, if the plaintext is of 3 bytes, 5 bytes of padding will be added (green is plaintext and yellow is padding): Similarly, for 6 bytes of plaintext, 2 bytes of padding will be added:\nNotice that for 5 bytes padding, we added 05 and for 2 bytes padding we added 02 (it’s in hexadecimal). What if plaintext is size of a block? We will still add padding by adding another block as shown below:\nCBC Decryption Mode Below figure describes CBC mode decryption (source: Wikipedia):\nThe receiver will use CBC decryption to obtain the plaintext + padding. The receiver will then remove padding to recover the original message. But if the receiver finds final N bytes not equal to N, it will return an error, we will call it error_padding. For example, the following block will return an error:\nIn above block, the 03 indicates that the padding is of size 3 bytes, but only 2 bytes were found. And if the receiver receives an invalid cipher text and valid padding, it will also return an error, let’s call it error_cipher. In a padding oracle attack, if an attacker can detect these errors, he can recover plaintext!\nSituation We assume that attacker has access to ciphertexts C1 and C2, and he is trying to recover the plaintext (P2):\nOriginally, suppose that the values of C1, I2, and P2 were as below (in hexadecimal): C1 = I2 = P2 = C1 ⊕ I2 = We can see that P2 has 3 bytes of padding. Attacker does not have knowledge of I2 and P2, he will only modify C1 and try to recover P2.\nThe Attack Attacker will try to cause errors by modifying the cipher text, he especially wants to see error_padding. To do so, attacker will start modifying the C1 bytes starting from the first byte, e.g., attacker will send the following C1 (red part is the modified one):\nThis will cause an error_cipher but not error_padding as padding bytes are still not changed, attacker will continue changing bytes until it reaches 6th byte:\nThis will cause an error_padding, because the XOR of 6th byte (A1) with 6th byte of I2 (06) is not 03. Attacker learned from this error that there is 3 bytes of padding, or the last three bytes of plaintext is 03. Using this information, attacker can find out final 3 bytes of I2, for example, for right most byte (using unmodified C1 here):\n90 ⊕ I2 (8th byte) = 03 We can say: I2 (8th byte) = 90 ⊕ 03 = 93 Similarly: I2 (7th byte) = 1C ⊕ 03 = 1F And: I2 (6th byte) = 05 ⊕ 03 = 06 So attacker knows following about the I2 (X are unknown values):\nNext, attacker wants to increase the padding bytes to 4, i.e., final four bytes of plaintext should be 04. Since attacker already knows last 3 bytes of I2, he can easily make that last three bytes of P2 to be 04. Attacker wants this: 8th byte of plaintext = 04 = C1 (8th byte) ⊕ I2 (8th byte) Since he knows I2: C1 (8th byte) ⊕ 93 = 04 Yields to: C1 (8th byte) = 93 ⊕ 04 = 97 Similarly, attacker will calculate 7th and 6th byte of C1 to make the plaintext 04: C1 (7th byte) = 1F ⊕ 04 = 1B C1 (6th byte) = 06 ⊕ 04 = 02 Now, the C1 will look like this (blue are the changed bytes):\nWhich will produce a P2 with last 3 bytes equal to 04, but the receiver will return an error_padding because the 5th byte of P2 is not 04 and receiver is expecting 4 bytes of padding. Attacker doesn’t know 5th byte of I2, so he will try different values (brute force) of C1 at 5th byte until the receiver doesn’t respond with an error_padding or the 5th byte of P2 is 04. After brute forcing 5th byte of C1, attacker will not get any error for the below payload:\nSince 1A is producing 04 at 5th byte of P2, padding will be fine. Attacker can now calculate 5th byte of I2: Since 1A = I2 (5th byte) ⊕ 04 Yields to: I2 (5th byte) = 1A ⊕ 04 = 1E You can see in the original I2 value, the 5th byte is actually 1E. Now attacker can revert back to their original value of C1 and calculate original 5th byte of P2: EE ⊕ 1E = F0 If you see the original value of P2 at 5th byte, it’s actually F0. So, attacker can recover original plaintext byte! Attacker can continue, and make the padding equal to 5, and recover 4th byte of plaintext and so on…he can recover all the plaintext byte by byte using this method!\n","wordCount":"946","inLanguage":"en","datePublished":"2023-07-24T07:10:07-04:00","dateModified":"2023-07-24T07:10:07-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ahsan-aziz.github.io/blog/padding-oracle/"},"publisher":{"@type":"Organization","name":"Ahsan's Blog","logo":{"@type":"ImageObject","url":"https://ahsan-aziz.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ahsan-aziz.github.io accesskey=h title="Ahsan's Blog (Alt + H)">Ahsan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Padding Oracle Attack</h1><div class=post-meta><span title='2023-07-24 07:10:07 -0400 -0400'>July 24, 2023</span></div></header><div class=post-content><p>This post is an effort to explain the padding oracle attack for Cipher Block Chaining (CBC) mode of encryption. In a successful attack, an attacker can recover the plaintext without any knowledge of the key. If the application, which is handling the decryption, leaks information about the valid and invalid padding, an attacker can send specially crafted ciphertext blocks and recover the plaintext. Below are the detials of the attack.</p><h2 id=padding>Padding<a hidden class=anchor aria-hidden=true href=#padding>#</a></h2><p>First, let&rsquo;s discuss how padding works. As CBC is a block cipher, data is encrypted in blocks and all the blocks are of equal size. Before encryption, the plaintext is divided into blocks, and because the plaintext can be of arbitrary length, we need to add padding to match the block size. In PKCS#5, the final block of plaintext is padded with N bytes of value N.<br><br>For example, for an 8 byte block, if the plaintext is of 3 bytes, 5 bytes of padding will be added (green is plaintext and yellow is padding):<br><img loading=lazy src=/images/padding-oracle/image1.png alt=padding1></p><p>Similarly, for 6 bytes of plaintext, 2 bytes of padding will be added:</p><p><img loading=lazy src=/images/padding-oracle/image2.png alt=padding2></p><p>Notice that for 5 bytes padding, we added 05 and for 2 bytes padding we added 02 (it’s in hexadecimal). What if plaintext is size of a block? We will still add padding by adding another block as shown below:</p><p><img loading=lazy src=/images/padding-oracle/image3.png alt=padding3></p><h2 id=cbc-decryption-mode>CBC Decryption Mode<a hidden class=anchor aria-hidden=true href=#cbc-decryption-mode>#</a></h2><p>Below figure describes CBC mode decryption (source: <a href=https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation##/media/File:CBC_decryption.svg>Wikipedia</a>):</p><p><img loading=lazy src=/images/padding-oracle/image4.png alt=decryption4></p><p>The receiver will use CBC decryption to obtain the plaintext + padding. The receiver will then remove padding to recover the original message. But if the receiver finds final N bytes not equal to N, it will return an error, we will call it <strong>error_padding</strong>. For example, the following block will return an error:</p><p><img loading=lazy src=/images/padding-oracle/image5.png alt=decryption5></p><p>In above block, the 03 indicates that the padding is of size 3 bytes, but only 2 bytes were found.<br><br>And if the receiver receives an invalid cipher text and valid padding, it will also return an error, let’s call it <strong>error_cipher</strong>.<br><br>In a padding oracle attack, if an attacker can detect these errors, he can recover plaintext!</p><h2 id=situation>Situation<a hidden class=anchor aria-hidden=true href=#situation>#</a></h2><p>We assume that attacker has access to ciphertexts C1 and C2, and he is trying to recover the plaintext (P2):</p><p><img loading=lazy src=/images/padding-oracle/image6.png alt=situation6></p><p>Originally, suppose that the values of C1, I2, and P2 were as below (in hexadecimal):<br>C1 =
<img loading=lazy src=/images/padding-oracle/image7.png alt=situation7></p><p>I2 =
<img loading=lazy src=/images/padding-oracle/image8.png alt=situation8></p><p>P2 = C1 ⊕ I2 =
<img loading=lazy src=/images/padding-oracle/image9.png alt=situation9></p><p>We can see that P2 has 3 bytes of padding. Attacker does not have knowledge of I2 and P2, he will only modify C1 and try to recover P2.</p><h2 id=the-attack>The Attack<a hidden class=anchor aria-hidden=true href=#the-attack>#</a></h2><p>Attacker will try to cause errors by modifying the cipher text, he especially wants to see <strong>error_padding</strong>. To do so, attacker will start modifying the C1 bytes starting from the first byte, e.g., attacker will send the following C1 (red part is the modified one):</p><p><img loading=lazy src=/images/padding-oracle/image10.png alt=attack10></p><p>This will cause an <strong>error_cipher</strong> but not <strong>error_padding</strong> as padding bytes are still not changed, attacker will continue changing bytes until it reaches 6th byte:</p><p><img loading=lazy src=/images/padding-oracle/image11.png alt=attack11></p><p>This will cause an <strong>error_padding</strong>, because the XOR of 6th byte (A1) with 6th byte of I2 (06) is not 03. Attacker learned from this error that there is 3 bytes of padding, or the last three bytes of plaintext is 03.<br><br>Using this information, attacker can find out final 3 bytes of I2, for example, for right most byte (using unmodified C1 here):</p><p>90 ⊕ I2 (8th byte) = 03<br>We can say: I2 (8th byte) = 90 ⊕ 03 = 93<br>Similarly: I2 (7th byte) = 1C ⊕ 03 = 1F<br>And: I2 (6th byte) = 05 ⊕ 03 = 06<br><br>So attacker knows following about the I2 (X are unknown values):</p><p><img loading=lazy src=/images/padding-oracle/image12.png alt=attack12></p><p>Next, attacker wants to increase the padding bytes to 4, i.e., final four bytes of plaintext should be 04. Since attacker already knows last 3 bytes of I2, he can easily make that last three bytes of P2 to be 04.<br><br>Attacker wants this:
8th byte of plaintext = 04 = C1 (8th byte) ⊕ I2 (8th byte)<br><br>Since he knows I2:<br>C1 (8th byte) ⊕ 93 = 04<br>Yields to: C1 (8th byte) = 93 ⊕ 04 = 97<br><br>Similarly, attacker will calculate 7th and 6th byte of C1 to make the plaintext 04:<br>C1 (7th byte) = 1F ⊕ 04 = 1B<br>C1 (6th byte) = 06 ⊕ 04 = 02<br><br>Now, the C1 will look like this (blue are the changed bytes):</p><p><img loading=lazy src=/images/padding-oracle/image13.png alt=attack13></p><p>Which will produce a P2 with last 3 bytes equal to 04, but the receiver will return an <strong>error_padding</strong> because the 5th byte of P2 is not 04 and receiver is expecting 4 bytes of padding. Attacker doesn’t know 5th byte of I2, so he will try different values (brute force) of C1 at 5th byte until the receiver doesn’t respond with an <strong>error_padding</strong> or the 5th byte of P2 is 04. After brute forcing 5th byte of C1, attacker will not get any error for the below payload:</p><p><img loading=lazy src=/images/padding-oracle/image14.png alt=attack14></p><p>Since 1A is producing 04 at 5th byte of P2, padding will be fine. Attacker can now calculate 5th byte of I2:<br>Since 1A = I2 (5th byte) ⊕ 04<br>Yields to: I2 (5th byte) = 1A ⊕ 04 = 1E<br><br>You can see in the original I2 value, the 5th byte is actually 1E.<br><br>Now attacker can revert back to their original value of C1 and calculate original 5th byte of P2:<br>EE ⊕ 1E = F0<br><br>If you see the original value of P2 at 5th byte, it’s actually F0. So, attacker can recover original plaintext byte!<br><br>Attacker can continue, and make the padding equal to 5, and recover 4th byte of plaintext and so on…he can recover all the plaintext byte by byte using this method!</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ahsan-aziz.github.io>Ahsan's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>